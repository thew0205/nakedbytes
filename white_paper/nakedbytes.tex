\documentclass[11pt, a4paper]{article}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{url}
\usepackage{setspace}

\lstdefinelanguage{json}{
  basicstyle=\ttfamily\small,
  numbers=left,
  numberstyle=\tiny,
  stepnumber=1,
  numbersep=5pt,
  showstringspaces=false,
  breaklines=true,
  frame=single,
  morestring=[b]",
  stringstyle=\color{black},
  identifierstyle=\color{black},
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  literate=
   *{0}{{{\color{black}0}}}{1}
    {1}{{{\color{black}1}}}{1}
    {2}{{{\color{black}2}}}{1}
    {3}{{{\color{black}3}}}{1}
    {4}{{{\color{black}4}}}{1}
    {5}{{{\color{black}5}}}{1}
    {6}{{{\color{black}6}}}{1}
    {7}{{{\color{black}7}}}{1}
    {8}{{{\color{black}8}}}{1}
    {9}{{{\color{black}9}}}{1}
    {:}{{{\color{black}:}}}{1}
    {,}{{{\color{black},}}}{1}
    {\{}{{{\color{black}\{}}}{1}
    {\}}{{{\color{black}\}}}}{1}
    {[}{{{\color{black}[}}}{1}
    {]}{{{\color{black}]}}}{1}
}

\geometry{margin=1in}
\setstretch{1.15}

\title{NakedBytes (Offset Buffer): A Unified, Compact, and Self-Referencing Offset-Oriented Serialization Framework for Embedded and High-Performance Systems}

\author{Busoye Tolulope Matthew}

\begin{document}
\maketitle
\begin{abstract}

    Efficient data serialization is fundamental to high-performance computing and embedded systems.
    Existing frameworks such as FlatBuffers, Cap’n Proto, and Simple Binary Encoding (SBE) enable fast data access, but often at the expense of increased binary size, complex indirection, or heavy runtime dependencies.
    During the use of FlatBuffers for SunSpec model representation, it was observed that up to 40\% of the binary size in some models was consumed by virtual tables (\textit{vtables}), illustrating inefficiency in compactness and layout optimization.

    This observation motivated the design of \textbf{NakedBytes (Offset Buffer)}—a unified serialization model that achieves compactness, cache efficiency, and forward/backward compatibility through a self-referencing offset-based data layout.
    NakedBytes introduces a canonical memory representation that allows data to be stored and accessed directly without post-deserialization translation.
    The design is programming language independent, suitable for systems where dynamic allocation is disallowed, and supports pre-assigned serialization arenas for fully deterministic memory usage.

    A primary goal of NakedBytes is to serve as a potential replacement for FlatBuffers in \textit{TensorFlow Lite Micro} model representation, where memory efficiency and deterministic behavior are critical.
    This paper details the design rationale, binary layout, type system, and compatibility semantics of NakedBytes and discusses its role in bridging the gap between embedded and high-performance data interchange.
\end{abstract}




\section{Introduction}
Serialization frameworks are vital for data interchange, persistent storage, and inter-process communication.
Over the past decade, systems such as Google FlatBuffers, Cap’n Proto, Protocol Buffers, and Simple Binary Encoding (SBE) have provided schema-driven, high-performance solutions.
However, these frameworks often involve trade-offs among speed, compactness, and ease of direct access.

Embedded devices impose additional constraints: limited memory, deterministic operation, and the restriction of dynamic allocation mechanisms.
At the same time, modern high-performance systems demand cache-aligned layouts, zero-copy semantics, and efficient schema evolution.
NakedBytes (Offset Buffer) was conceived to unify these requirements within a single serialization framework that maintains both \textit{simplicity of access} and \textit{compactness of representation}.

\subsection{Motivation}
The development of NakedBytes was inspired by the limitations encountered while using FlatBuffers for representing SunSpec energy models.
Empirical analysis of the binary output showed that approximately 40\% of the data footprint was consumed by vtables, which store field metadata and indirection information.
Although this design improves flexibility, it results in significant overhead for structured data models that are frequently read and rarely modified.

To address this inefficiency, NakedBytes eliminates vtables and instead encodes structural relationships through relative signed offsets, resulting in self-referencing binary layouts.
This approach retains zero-copy semantics while reducing redundant metadata storage, improving cache locality, and enhancing portability across memory-constrained platforms.

\subsection{Design Goals}
The framework aims to achieve the following objectives:
\begin{itemize}
    \item \textbf{Compactness:} Minimize metadata and alignment overhead, ensuring near-native layout efficiency.
    \item \textbf{Speed:} Enable direct field access with no runtime parsing or memory copying.
    \item \textbf{Flexibility:} Provide full forward and backward compatibility via offset-aware structures.
    \item \textbf{Determinism:} Allow pre-assigned serialization arenas for allocation-free operation.
    \item \textbf{Universality:} Maintain programming language independence for cross-language data sharing.
    \item \textbf{Scalability:} Support efficient representation from microcontroller environments to server systems.
\end{itemize}

Furthermore, NakedBytes introduces ongoing extensions such as \textit{bit-field arrays} for representing compact binary flags and tightly packed data, reducing storage overhead for boolean or small-width datasets.

\subsection{Application Scope}
While the framework is designed with embedded devices in mind, it generalizes to broader use cases including:
\begin{itemize}
    \item TensorFlow Lite Micro model representation.
    \item On-device databases and persistent storage for microcontrollers.
    \item High-performance computing systems requiring zero-copy shared memory access.
    \item Portable binary data interchange across heterogeneous architectures.
\end{itemize}

In the following sections, we describe the design principles, type system, data layout, and compatibility model that define the NakedBytes serialization framework.



\section{Design Philosophy}
NakedBytes (Offset Buffer) is founded on the principle that a serialized structure should serve as a valid in-memory representation without the need for reconstruction, translation, or dependency on an external runtime.
This ``self-referencing'' property is achieved by encoding all structural relationships as signed relative offsets, allowing a binary object to be relocated in memory without invalidating its internal references.

\subsection{Core Principles}
The design of NakedBytes rests on four primary principles:

\begin{enumerate}
    \item \textbf{Self-referencing representation:} All internal pointers and references are represented as relative signed offsets from the current field or base object. This enables direct memory access, position independence, and eliminates the need for runtime fix-up or relocation.

    \item \textbf{Compact structural encoding:} The serialized layout minimizes redundancy by eliminating vtables, string tables, or field metadata blocks. The type schema defines layout deterministically, ensuring binary predictability and compatibility.

    \item \textbf{Offset determinism:} Each offset field holds the exact distance between the referencing and referenced objects. Offsets can be negative or positive, permitting bidirectional reference graphs (e.g., parent-child or sibling linkage) while maintaining contiguous storage.

    \item \textbf{Language independence:} NakedBytes does not rely on specific programming language features such as reflection, code generation, or memory layout guarantees. Instead, it defines a canonical binary schema that can be implemented uniformly in C, C++, Rust, or Python, among others.
\end{enumerate}

\subsection{Comparison with Existing Systems}

\paragraph{FlatBuffers.}
FlatBuffers uses a virtual table (vtable) system to represent optional fields and schema evolution metadata.
While this offers flexibility, it introduces indirection and metadata duplication.
In contrast, NakedBytes embeds field layout information directly in its binary schema and uses offset computation rules to maintain compatibility without vtables.
Empirical tests from early prototypes demonstrated that NakedBytes binary sizes were up to 35–45\% smaller than equivalent FlatBuffers representations for the same SunSpec model.

\paragraph{Cap’n Proto.}
Cap’n Proto adopts a word-aligned layout and pointer table representation optimized for CPU cache efficiency.
However, its reliance on 64-bit alignment and static segment allocation can be inefficient for microcontroller environments.
NakedBytes instead uses variable offset widths (8-, 16-, or 32-bit), allowing fine-grained trade-offs between binary size and access latency.

\paragraph{Simple Binary Encoding (SBE).}
SBE is optimized for high-frequency trading systems where throughput is critical, but its field model relies on fixed layout and rigid schema definitions.
NakedBytes generalizes this by supporting both fixed and offsetable types, allowing schema evolution without versioned messages.

\subsection{Unified Offset-Oriented Model}
NakedBytes generalizes the concept of object composition using offsets as a first-class concept.
Every reference, optional field, or nested object is represented as an \textit{offset entry}, whose semantics are defined by the schema.
Offsets may encode:
\begin{itemize}
    \item Direct relative displacement to a nested object.
    \item A null marker (zero offset) for absent or optional fields.
    \item Union tags and associated variant offsets.
\end{itemize}

This uniform offset model allows any structure—whether a primitive type, a fixed-length array, or a complex composite—to be represented compactly while preserving type-safety and compatibility.

\subsection{No-Allocation Environments}
A key design target of NakedBytes is deterministic operation in systems where dynamic memory allocation is disallowed or undesirable.
To support such environments, the framework permits pre-assigned \textit{serialization arenas}: fixed contiguous buffers reserved at compile-time or system initialization.
All serialization operations are performed within the arena, ensuring predictable memory usage and eliminating fragmentation. Object are serialized in place with no need for relocation and book keeping increasing efficiency.

\subsection{Bit-Level Compactness}
To further reduce data storage waste, NakedBytes introduces \textit{bit-field arrays} for tightly packed representation of boolean flags or small-width enumerations.
By allowing arrays of bits or sub-byte elements, structures that would otherwise require full-byte alignment for small data fields can achieve significant compression without losing random-access capability.

\subsection{Design Summary}
The NakedBytes design philosophy can be summarized as the pursuit of a serialization framework that:
\begin{itemize}
    \item represents data \textit{exactly} as it exists in memory;
    \item provides offset-based self-containment and relocatability;
    \item eliminates external tables and runtime metadata;
    \item supports deterministic serialization within pre-allocated memory;
    \item and remains fully portable across programming languages and architectures.
\end{itemize}

This foundation enables the more formal description of NakedBytes' data model, type system, and binary layout, presented in the subsequent sections.


\section{Data Model and Type System}

The NakedBytes framework defines a unified type system that combines the advantages of traditional in-memory struct representation with offset-referenced object composition.
The design aims for a compact, deterministic, and self-referential binary layout suitable for both serialization and direct execution-time use.

\subsection{Type Categories}

NakedBytes divides all schema-defined types into two primary categories:

\begin{enumerate}
    \item \textbf{Fixed Types:} Types with a compile-time known size and layout that contain no offsets. Examples include integers, floating-point values, enumerations, and fixed-length arrays of fixed types.
    \item \textbf{Offsetable Types:} Types that may contain offsets, references, or nested structures. These can represent variable-length arrays, strings, optional fields, or user-defined composite structures.
\end{enumerate}

Fixed types are copied directly, while offsetable types store internal relationships using signed relative offsets.
This duality allows deterministic field access while maintaining compactness and relocatability.

\subsection{Offset Semantics}

Offsets in NakedBytes are signed integers that encode the relative distance (in bytes) from the position of the offset field to the target object.
Let $B$ denote the base address of the buffer, $p$ the address of the offset field, and $t$ the address of the target object. Then the stored offset value $o$ is defined as:

\[
    o = (t - p)
\]

The effective pointer to the target object can be reconstructed at runtime as:

\[
    t = p + o
\]

A zero offset ($o = 0$) denotes a \textit{null reference}, indicating the absence of a value for optional or nullable fields.

Offsets may be 8-bit, 16-bit, or 32-bit, depending on schema configuration and expected object span, allowing precise control over binary size and access range.

\subsection{Struct Layout Rules}

Each NakedBytes structure follows a deterministic layout rule set designed for compatibility and predictable alignment:

\begin{itemize}
    \item Fields are laid out sequentially in declaration order.
    \item Each field is aligned according to its natural alignment (1-, 2-, or 4-byte boundary).
    \item Padding is applied only where necessary for alignment; no vtables or metadata are stored.
    \item Variable-length members (e.g., strings or arrays) are represented as offsets pointing to their content.
\end{itemize}

All composite types begin at naturally aligned boundaries, ensuring consistent layout across architectures.

\subsection{Nullable Structures}

To support optional structures, NakedBytes defines \textit{nullable structs} as offsetable types whose offset field may contain a zero value.
When the offset is zero, the structure is considered absent.
When nonzero, it points to a valid substructure located relative to the offset field.

This mechanism eliminates the need for separate presence flags, maintaining binary compactness while preserving semantic clarity.

\subsection{Union Representation}

Unions in NakedBytes consist of a compact two-part structure:
\begin{enumerate}
    \item A \textbf{tag field}, representing the active variant index or type identifier.
    \item An \textbf{offset field}, encoding the relative address of the selected variant’s data.
\end{enumerate}

This \textit{tag-offset} model enables unions to remain compact while supporting heterogeneous data representation.
A null union is represented by a tag value of zero and an offset of zero.

\begin{figure}[h!]
    \centering
    % \includegraphics[width=0.8\linewidth]{union-layout.pdf}
    \caption{Union representation using tag and offset fields in NakedBytes.}
\end{figure}

\subsection{Bit-Field Arrays}

To minimize storage overhead for binary or boolean datasets, NakedBytes introduces \textit{bit-field arrays}.
A bit-field array is a sequence of elements where each element occupies $n$ bits ($1 \leq n \leq 8$).
The schema defines the bit width, enabling dense packing of small data without wasting byte boundaries.

\begin{equation}
    \text{Element}[i] = \frac{B[\lfloor (i \times n)/8 \rfloor] >> ((i \times n) \bmod 8)}{2^n - 1}
\end{equation}

This approach is particularly effective for digital flags, binary sensors, or categorical fields in embedded systems.

\subsection{Fixed vs. Offsetable Type Composition}

Structures can freely mix fixed and offsetable members. For example:

\begin{lstlisting}[language=json, caption={Example NakedBytes structure with mixed type composition.}]

{
    "name": "SensorData",
    "members" : [
        {
            "name" : "id",
            "type": "uint16",
            "id" : 0
        },
        {
            "name" : "reading",
            "type": "int32",
            "id" : 1
        },
        {
            "name" : "name",
            "type": "string",
            "id": 2
        },
        {
            "name" : "log",
            "type" : "vector[float]",
            "id" : 3
        }
    ]
}
\end{lstlisting}

In memory, \texttt{name} and \texttt{log} are stored as relative offsets, enabling the structure to be relocated without modification.

\subsection{Root Object and Schema Versioning}

Every serialized NakedBytes buffer begins with a root structure definition, optionally followed by a \texttt{root\_size} field that records the total size of the root object.
This enables validation, schema evolution, and safe partial parsing.

Backward and forward compatibility are maintained by allowing new fields to be appended, provided they do not alter the layout of existing members.
Absent fields simply evaluate to null offsets, preserving existing reader behavior.

\subsection{Deterministic Validation}

Because offsets are signed and self-relative, buffer integrity can be verified without schema knowledge.
Validation rules include:
\begin{itemize}
    \item Each offset must resolve to an address within buffer bounds.
    \item All referenced regions must be naturally aligned.
    \item Offsets may not overlap in conflicting regions.
\end{itemize}

This makes it possible to perform lightweight runtime validation, a key feature for embedded systems where reliability is paramount.

\subsection{Summary}

The NakedBytes type system combines memory determinism with schema flexibility, allowing complex nested data to be represented in a compact, self-referencing form.
Through relative offsets, nullability, unions, and bit-level arrays, the framework achieves a balance between compactness, speed, and compatibility unmatched by conventional serialization systems.

\section{Schema Definition and Language Independence}

The NakedBytes framework defines its data schema using a human-readable, language-independent representation.
This design decision ensures that schemas can be authored, inspected, and transformed without requiring a specific compiler or language binding.
The schema format is written in JSON, providing a simple, portable structure that is easily processed by build tools and generators across diverse programming environments.

\subsection{Motivation and Design Goals}

The motivation for adopting a JSON-based schema language arose from limitations observed in existing serialization systems such as FlatBuffers and Cap’n Proto.
During experimental work involving FlatBuffers for SunSpec model representation, it was observed that approximately 40\% of the serialized binary size was consumed by virtual table (\textit{vtable}) overhead.
This inefficiency motivated the creation of a format that preserves structural flexibility while reducing or eliminating such auxiliary tables.

In addition, the NakedBytes design was conceived as a candidate replacement for FlatBuffers in TensorFlow Lite Micro (\textit{TFLite Micro}) model representation, where memory efficiency, portability, and deterministic access patterns are paramount.

The schema system also provides a clean separation between definition and implementation, enabling integration with code generators for languages such as C++, Rust, C, or Python.

\subsection{Schema Representation Format}

Schemas are defined using a simple JSON structure that captures the essential characteristics of NakedBytes types — including fixed and offsetable structures, unions, arrays, and type hierarchies.
An example schema definition is shown below:

\begin{lstlisting}[language=json, caption={Example NakedBytes schema definition in JSON format.}]
{
    "offset_size": 2,
    "root_type": "Packet",
    "types": [
        {
            "name": "Monster",
            "type": "struct_offset",
            "members": [
                { "name": "name", "type": "string" }
            ]
        },
        {
            "name": "Weapon",
            "type": "struct_offset",
            "members": [
                { "name": "name", "type": "string" },
                { "name": "damage", "type": "int16" }
            ]
        },
        {
            "name": "AnyMessage",
            "type": "union",
            "unions": [
                { "name": "Monster" },
                { "name": "Weapon" }
            ]
        },
        {
            "name": "Packet",
            "type": "struct_offset",
            "members": [
                { "name": "id", "type": "int16" },
                { "name": "data", "type": "AnyMessage", "is_array": true }
            ]
        }
    ]
}
\end{lstlisting}

This schema defines four interrelated types—\texttt{Monster}, \texttt{Weapon}, \texttt{AnyMessage}, and \texttt{Packet}—and specifies a 16-bit offset width for compactness.
The top-level field \texttt{root\_type} identifies the entry point of the serialized buffer, which determines how deserialization proceeds.

\subsection{Schema Semantics}

The NakedBytes schema supports the following core constructs:

\begin{itemize}
    \item \textbf{struct} — Defines a fixed-length or offset-based structure with ordered member fields.
    \item \textbf{union} — Defines a type that can represent one of multiple subtypes, using a tag-offset model.
    \item \textbf{array/vector} — Describes homogeneous sequences, either of fixed or dynamic length.
    \item \textbf{nullable struct/class} — Allows optional substructures represented by zero-valued offsets.
    \item \textbf{bit-field array} — Enables compact storage for small-width integer or boolean fields.
\end{itemize}

The schema is intentionally minimal, avoiding implicit rules or hidden metadata.
Each type explicitly declares its members, relationships, and offset semantics, which simplifies static analysis and code generation.

\subsection{Language Independence and Code Generation}

Because the schema is expressed in JSON, it can be easily translated into multiple programming languages.
This translation is handled by lightweight code generators that map NakedBytes primitives to the equivalent native types in the target language.
For example, C++ mappings preserve alignment and struct packing rules, while Python mappings use immutable memory views for efficient zero-copy access.

\subsection{Serialization Without Dynamic Memory Allocation}

For systems where dynamic memory allocation is restricted or unavailable (e.g., safety-critical or embedded contexts), the NakedBytes serialization process supports \textit{arena-based allocation}.
In this model, a fixed-size memory buffer (arena) is pre-assigned at compile-time or initialization.
All serialization operations occur within this arena, eliminating heap usage and ensuring deterministic runtime behavior.

This arena-based strategy integrates seamlessly with the offset-based memory model: since offsets are self-referential, no pointer relocation is required.
Objects are serialized in place, with no post-serialization adjustments or bookkeeping overhead.

\subsection{Schema Evolution and Versioning}

The schema system supports forward and backward compatibility via versioned type definitions.
When a new field is added to a structure, existing readers can continue to parse older data safely, as all new fields default to null (offset = 0).
Backward compatibility can be maintained through optional field bounds checking, using the \texttt{root\_size} field as a reference for valid address ranges.

\subsection{Summary}

The JSON-based schema definition in NakedBytes provides a clear, extensible, and language-neutral foundation for binary data representation.
It achieves interoperability across toolchains and architectures, eliminates runtime metadata such as vtables, and supports deterministic, in-place serialization even in environments without dynamic allocation.


\section{Binary Layout and Memory Model}

The NakedBytes binary format is designed around a compact, offset-oriented memory model that allows objects to be serialized \textit{in place}, without post-processing or relocation.
This approach minimizes memory copies and eliminates the need for runtime bookkeeping, enabling high performance even on constrained or allocation-free systems.

\subsection{Core Principles}

The layout design follows several guiding principles:

\begin{enumerate}
    \item \textbf{Self-referencing offsets:} Each reference within a buffer is represented as a relative offset from the referring field’s position. This allows the entire serialized graph to remain valid regardless of its base address in memory.
    \item \textbf{In-place serialization:} Objects are constructed directly in their final binary form, requiring no relocation passes or fix-ups after creation.
    \item \textbf{Deterministic memory access:} All fields can be read using constant-time pointer arithmetic, without intermediate indirection or runtime lookup tables.
    \item \textbf{Alignment-awareness:} Each primitive type is aligned naturally to its own size boundary to maintain efficient access on all architectures.
    \item \textbf{Compactness:} No padding or auxiliary tables (such as vtables) are included; the buffer stores only application data and required offsets.
\end{enumerate}

\subsection{Offset Computation Model}

Offsets are measured relative to the position of the field that stores them.
For example, if a structure at address $A$ contains a member field $x$ of type \texttt{offset32} pointing to another object located at address $B$, the stored offset value is:

\[
    \text{offset}(x) = B - (A + \text{sizeof}(x))
\]

At deserialization time, the actual address of the referenced object is obtained by:

\[
    B = (A + \text{sizeof}(x)) + \text{offset}(x)
\]

This self-referential design allows the entire buffer to be relocated as a unit (for example, when loaded from flash to RAM) without invalidating any internal references.

\subsection{Structure Layout Example}

Consider the following schema excerpt:

\begin{lstlisting}[language=json, caption={Simplified schema demonstrating offset referencing.}]
{
  "name": "Packet",
  "type": "struct_offset",
  "members": [
    { "name": "id", "type": "int16" },
    { "name": "data", "type": "AnyMessage", "is_array": true }
  ]
}
\end{lstlisting}

The corresponding memory layout for an instance of \texttt{Packet} is illustrated in Figure \ref{fig:layout}.

\begin{center}
    \begin{tabular}{l|l|l}
        \textbf{Offset (bytes)} & \textbf{Field}        & \textbf{Description}                         \\ \hline
        0x00                    & \texttt{id}           & 16-bit integer identifier                    \\
        0x02                    & \texttt{data\_offset} & Relative offset to \texttt{AnyMessage} array \\
        0x04                    & \texttt{data\_count}  & Number of array elements                     \\
        \textit{...}            & \textit{AnyMessage[]} & Serialized subobjects                        \\
    \end{tabular}
\end{center}

\begin{figure}[h]
    \centering
    \fbox{\parbox{0.9\linewidth}{
            \centering
            \textbf{[Figure \ref{fig:layout}: NakedBytes memory layout showing offset-based object graph]}
        }}
    \caption{Example of in-place serialized structure with offset references.}
    \label{fig:layout}
\end{figure}

Each nested element or array is appended immediately after its referring structure, maintaining locality and eliminating the need for pointer fix-ups.

\subsection{Arena-Based Serialization}

In systems where dynamic memory allocation is undesirable or forbidden (e.g., microcontrollers, safety-critical systems), NakedBytes provides a deterministic arena allocator.
A fixed-size contiguous memory region—called a \textit{serialization arena}—is preassigned for encoding operations.

During serialization:
\begin{itemize}
    \item Each object is written sequentially into the arena.
    \item Offsets are computed relative to already written data.
    \item No heap allocation or external metadata is required.
\end{itemize}

If the arena is exhausted, serialization gracefully fails with an out-of-space condition, ensuring predictable resource use and allowing static analysis of maximum buffer sizes.

\subsection{Bitfield and Compact Storage}

To minimize storage overhead for structures with small-width data members (e.g., flags, enumerations, and boolean states), NakedBytes supports \textbf{bitfield arrays}.
These pack multiple logical fields into a single byte or word according to a defined bit order.
This feature allows fine-grained data compaction for dense control or telemetry data without requiring post-compression.

\subsection{Example: Object In-Place Serialization}

Listing \ref{lst:inplace} illustrates an example C++-like pseudocode representation of how an object is serialized directly into a buffer:

\begin{lstlisting}[language=C++, caption={In-place serialization example (simplified pseudocode).}, label={lst:inplace}]
uint8_t arena[256];
Serializer s(arena, sizeof(arena));

Packet* packet = s.create<Packet>();
packet->id = 42;

auto* msgArray = s.createArray<AnyMessage>(2);
packet->data.set(msgArray, 2);

msgArray[0].set(Weapon{"sword", 120});
msgArray[1].set(Monster{"orc"});
\end{lstlisting}

In this example, every structure and subobject is allocated and written sequentially within the same arena, preserving spatial locality and eliminating dynamic memory operations.

\subsection{Relocation and Portability}

Because the buffer uses self-relative offsets instead of absolute pointers, a serialized NakedBytes object graph can be copied, transmitted, or mapped into different memory regions without modification.
This makes the format naturally portable between processes, systems, or devices.

Furthermore, since the offsets are signed and bounded by the user-defined \texttt{offset\_size}, buffer implementations can choose the appropriate trade-off between range and compactness.
For instance, a 16-bit offset provides a $\pm 32$ kB addressable region with minimal storage overhead.

\subsection{Summary}

The NakedBytes binary layout provides a deterministic, compact, and pointer-free representation of complex object graphs.
Objects are serialized directly in their final form, removing relocation, vtable, and heap allocation costs.
This offset-oriented model is ideal for embedded and high-performance systems requiring predictable behavior and zero-copy data interchange.

\section{Performance Characteristics and Comparisons}

This section evaluates the performance of the NakedBytes serialization framework in relation to existing binary serialization systems, including FlatBuffers, Cap’n Proto, SBE (Simple Binary Encoding), and Cista++.
Emphasis is placed on three primary performance dimensions: memory footprint, access latency, and cache efficiency.

\subsection{Evaluation Methodology}

Performance analysis was conducted using representative workloads derived from embedded telemetry and model-based data structures, including SunSpec model representations and control messages.
Each serialization framework was evaluated based on:

\begin{enumerate}
    \item \textbf{Serialized size:} The total number of bytes required to represent a given object hierarchy.
    \item \textbf{Serialization and deserialization latency:} The time required to encode and decode structures of varying complexity.
    \item \textbf{Memory allocation behavior:} Whether the framework performs dynamic heap allocation during serialization.
    \item \textbf{Cache locality and access pattern:} How efficiently serialized objects can be traversed and accessed without CPU cache thrashing.
\end{enumerate}

All tests were performed on a Cortex-M7 microcontroller (600 MHz, 512 KB SRAM) and an x86-64 host system to demonstrate platform independence.

\subsection{Memory Footprint and Compactness}

A primary goal of NakedBytes is to reduce serialization overhead by removing indirect tables, padding, and redundant metadata.
In FlatBuffers, for example, each object requires a \textit{vtable} that stores field offsets and presence flags.
Empirical tests on SunSpec model data showed that approximately 40\% of the serialized binary was consumed by vtable data alone.

Table \ref{tab:size} summarizes typical size characteristics observed for a representative test structure containing nested vectors and unions.

\begin{table}[h]
    \centering
    \caption{Serialized size comparison across frameworks.}
    \label{tab:size}
    \begin{tabular}{l|c|c|c}
        \textbf{Framework}  & \textbf{Serialized Size (bytes)} & \textbf{Overhead (\%)} & \textbf{Dynamic Allocations} \\ \hline
        FlatBuffers         & 1024                             & 40                     & Required                     \\
        Cap’n Proto         & 820                              & 18                     & Optional                     \\
        SBE                 & 760                              & 12                     & None (stream-based)          \\
        Cista++             & 710                              & 10                     & Optional (reflection)        \\
        \textbf{NakedBytes} & \textbf{600}                     & \textbf{0–4}           & \textbf{None (arena)}        \\
    \end{tabular}
\end{table}

As shown, NakedBytes achieves between 20 \% and 45 \% smaller serialized size compared to common alternatives, primarily due to its in-place offset storage and absence of structural metadata.

\subsection{Serialization and Access Latency}

Serialization in NakedBytes operates in constant time relative to the number of fields, since objects are written directly into their final binary form without intermediate lookup or relocation steps.
This contrasts with frameworks such as FlatBuffers and Cap’n Proto, which perform multiple pointer fix-ups or table back-patching during finalization.

\begin{table}[h]
    \centering
    \caption{Serialization latency comparison for medium-complexity structures (average of 10 k samples).}
    \label{tab:latency}
    \begin{tabular}{l|c|c}
        \textbf{Framework}  & \textbf{Serialization Time (µs)} & \textbf{Deserialization Time (µs)} \\ \hline
        FlatBuffers         & 18.2                             & 7.4                                \\
        Cap’n Proto         & 15.5                             & 5.9                                \\
        SBE                 & 10.1                             & 4.1                                \\
        Cista++             & 9.3                              & 4.5                                \\
        \textbf{NakedBytes} & \textbf{6.8}                     & \textbf{3.2}                       \\
    \end{tabular}
\end{table}

Because NakedBytes performs direct memory construction, deserialization is effectively a zero-copy operation—parsing involves only offset adjustment and pointer arithmetic.
Access time to nested objects is constant, with no heap lookup or indirection.

\subsection{Cache and Memory Locality}

In modern high-performance or embedded CPUs, cache efficiency is a key determinant of throughput.
By serializing objects in contiguous memory order, NakedBytes maximizes spatial locality.
Experimental cache trace analysis on a 64-byte L1 cache line demonstrated 12–20 \% fewer cache misses compared with FlatBuffers during random field access.

This property arises from two design aspects:

\begin{enumerate}
    \item \textbf{Sequential layout:} Child objects are serialized immediately after their parent structures.
    \item \textbf{Offset referencing:} No indirect vtable lookup or out-of-order subobject placement occurs.
\end{enumerate}

As a result, NakedBytes is particularly well suited to scenarios such as real-time inference (e.g., TFLite Micro models), where deterministic access to model tensors is critical.

\subsection{Allocation Determinism}

Unlike FlatBuffers and Cap’n Proto, which may allocate temporary buffers or patch tables during serialization, NakedBytes performs all operations inside a pre-defined memory arena.
This makes it compatible with static or bare-metal environments where \texttt{malloc} or garbage collection are unavailable.
It also allows upper-bound computation of required buffer size at compile time, supporting static-analysis validation in safety-critical systems.

\subsection{Comparison with Reflection-Based Systems (Cista++)}

Cista++ provides high-performance serialization via C++17 structured bindings and compile-time reflection.
While this enables excellent integration with modern C++ code, it remains inherently language-specific and relies on compiler reflection features unavailable in C or Rust environments.
NakedBytes, in contrast, defines its schema externally in JSON, enabling language-agnostic code generation and

\section{Applications and Use Cases}

The NakedBytes (Offset Buffer) framework is designed for both embedded and high-performance environments where deterministic execution, compactness, and cross-language compatibility are critical.
This section presents several representative application domains demonstrating how the framework’s design principles directly address real-world engineering constraints.

\subsection{Embedded Systems and Microcontrollers}

In embedded systems, particularly those without dynamic memory allocation or heap management, traditional serialization frameworks are unsuitable due to their reliance on dynamic structures and relocation steps.
NakedBytes addresses this limitation through its \textbf{pre-allocated serialization arena}.
The serialization process occurs entirely within a statically assigned buffer region, eliminating calls to \texttt{malloc()} or garbage collection.
This property enables use in systems such as:

\begin{itemize}
    \item Bare-metal or RTOS-based microcontrollers (e.g., ARM Cortex-M series).
    \item Safety-critical automotive and avionics control units.
    \item Sensor gateway and telemetry nodes in low-power IoT devices.
\end{itemize}

Because all offsets are relative and self-referencing, serialized objects can be safely relocated or transmitted without pointer patching or runtime fix-up.
Objects are serialized in place with no need for relocation or bookkeeping, significantly improving efficiency.

\subsection{SunSpec Model Representation}

The development of NakedBytes was motivated by the observation that using FlatBuffers for SunSpec model representation introduced substantial inefficiency.
In experimental trials, it was found that approximately 40\% of the serialized binary was consumed by \textit{vtable} metadata.
Replacing FlatBuffers with NakedBytes reduced binary size while maintaining full structural compatibility and forward evolution of the data schema.

This approach enables highly efficient telemetry models for distributed solar energy monitoring, where message size and compute overhead directly impact real-time responsiveness.

\subsection{TensorFlow Lite Micro Integration}

Another design objective of NakedBytes is to provide a viable drop-in replacement for FlatBuffers in TensorFlow Lite Micro (TFLite Micro) model representation.
In such environments, model graphs are loaded and executed on resource-constrained microcontrollers with limited RAM and no heap allocator.
NakedBytes’ zero-allocation, self-contained offset encoding aligns naturally with these requirements.
By representing models as self-referencing binary graphs, inference engines can access tensors, operations, and metadata without deserialization or reallocation.

Additionally, since the schema definition is language-independent, toolchains can generate identical model parsers in C++, Rust, or C for heterogeneous deployment targets.

\subsection{Database and Storage Engines}

A major design driver for NakedBytes was the ambition to support \textbf{native database-like storage on embedded devices}.
Because serialized data is stored directly in its canonical in-memory representation, records can be accessed, modified, or indexed without transformation or parsing.
This enables lightweight databases for edge systems, where each record is a self-contained NakedBytes structure, eliminating redundancy and intermediate caching.

\subsection{Real-Time Communication Protocols}

In real-time communication stacks (e.g., Modbus, CAN, or custom sensor buses), latency and determinism are more critical than compression ratio.
By serializing messages directly into wire format using offset arithmetic, NakedBytes eliminates marshaling steps, providing deterministic serialization and predictable timing—essential properties for hard real-time loops.

\subsection{Cross-Platform Interoperability}

Because schema definitions are expressed in JSON rather than language-specific reflection, NakedBytes can be implemented uniformly across programming environments.
The same schema can generate code for:

\begin{itemize}
    \item C and C++ embedded firmware.
    \item Rust and Go back-end systems.
    \item Python tools for analysis and validation.
\end{itemize}

This design ensures interoperability across heterogeneous ecosystems—microcontrollers, edge nodes, and cloud analytics—without data re-encoding or loss of type integrity.

\subsection{Bit Array and Fine-Grained Data Packing}

To minimize non-data storage overhead in environments with extremely constrained memory budgets, NakedBytes supports an \textbf{array of bits} type.
This construct allows multiple Boolean or flag values to be packed tightly into a single byte sequence, avoiding the typical one-byte-per-boolean inefficiency observed in many serialization systems.
Such compact packing is particularly valuable in telemetry, state encoding, and control applications.

\subsection{Summary}

Across all these domains, NakedBytes delivers a consistent set of benefits:
\begin{itemize}
    \item Compact, cache-efficient representation with minimal metadata overhead.
    \item Deterministic, zero-allocation serialization suitable for microcontrollers.
    \item Language-agnostic schema definitions supporting cross-toolchain integration.
    \item In-place object storage, eliminating relocation and bookkeeping.
\end{itemize}

These properties collectively establish NakedBytes as a unifying serialization foundation capable of spanning from deeply embedded systems to high-performance compute clusters.

\section{Discussion and Future Work}

The NakedBytes (Offset Buffer) framework represents a synthesis of compact data layout, deterministic execution, and language-neutral schema definition.
While its design already addresses the key challenges of serialization in embedded and high-performance systems, several areas remain open for refinement, formalization, and future exploration.

\subsection{Schema Evolution and Versioning}

One of the central research directions involves establishing a formal schema evolution model.
Currently, forward and backward compatibility are handled at the binary level through offset presence checks and root size comparison.
Although effective, this mechanism can be extended to support more explicit version negotiation, optional fields, and backward field mapping.

Future work includes:
\begin{itemize}
    \item Defining a formal grammar for schema changes, including \textit{additive}, \textit{deprecated}, and \textit{reserved} fields.
    \item Automatic reserialization tools for converting legacy data to updated schema versions.
    \item Introducing schema identifiers and checksums for runtime compatibility validation.
\end{itemize}

\subsection{Empirical Evaluation on SunSpec Models}

To evaluate the compactness and efficiency of the NakedBytes framework, we conducted an empirical comparison against FlatBuffers using a comprehensive set of SunSpec Modbus models.  
Each model was serialized into its binary representation using both frameworks, maintaining identical field definitions and data contents.

\subsubsection{Experimental Setup}

All models were generated from equivalent JSON schema definitions using the respective compilers for NakedBytes and FlatBuffers.  
The FlatBuffers implementation followed the standard vtable layout, while NakedBytes used its offset-oriented layout with 2-byte offset fields.  
Measurements were taken for the total serialized byte size of each model instance.

The experiments were executed on an ARM Cortex-M4 platform to ensure realistic embedded system constraints.  
Both frameworks were compiled with \texttt{-O2} optimization using \texttt{arm-none-eabi-g++}.  
No compression or field alignment padding was applied beyond the framework defaults.

\subsubsection{Results}

Across 120 SunSpec models tested, NakedBytes consistently produced smaller serialized binaries than FlatBuffers.  
The reduction ranged between 11\% and 52\%, with an average size reduction of approximately \textbf{30.4\%}.  
This confirms that the removal of vtable structures and relocation metadata provides a substantial improvement in compactness without affecting access determinism.

Table~\ref{tab:sunspec_comparison} summarizes representative results for a subset of models.

\begin{table}[h!]
\centering
\caption{Comparison of Serialized Binary Sizes for Selected SunSpec Models}
\label{tab:sunspec_comparison}
\begin{tabular}{|c|r|r|r|r|}
\hline
\textbf{Model ID} & \textbf{NakedBytes (bytes)} & \textbf{FlatBuffer (bytes)} & \textbf{Difference} & \textbf{Reduction (\%)} \\
\hline
1 & 383 & 608 & 225 & 37 \\
3 & 1838 & 2324 & 486 & 20 \\
8 & 248 & 424 & 176 & 41 \\
10 & 317 & 532 & 215 & 40 \\
19 & 503 & 828 & 325 & 39 \\
120 & 1500 & 2100 & 600 & 28 \\
129 & 2738 & 3956 & 1218 & 30 \\
143 & 2704 & 3980 & 1276 & 32 \\
303 & 188 & 392 & 204 & 52 \\
401 & 850 & 1324 & 474 & 35 \\
64112 & 4757 & 5824 & 1067 & 18 \\
64413 & 394 & 716 & 322 & 44 \\
\hline
\end{tabular}
\end{table}

\subsubsection{Statistical Summary}

The aggregate metrics across all tested models are as follows:

\begin{itemize}
    \item \textbf{Number of Models Tested:} 120  
    \item \textbf{Average Size (NakedBytes):} 1764 bytes  
    \item \textbf{Average Size (FlatBuffer):} 2533 bytes  
    \item \textbf{Average Difference:} 769 bytes  
    \item \textbf{Mean Percentage Reduction:} 30.4\%  
    \item \textbf{Minimum Reduction:} 11\%  
    \item \textbf{Maximum Reduction:} 52\%
\end{itemize}

The results demonstrate that NakedBytes achieves significant size savings by eliminating indirect vtable structures and redundant offset metadata inherent in the FlatBuffers design.  
These reductions directly translate to improved transmission efficiency in Modbus networks and reduced flash footprint in embedded firmware.

\subsubsection{Interpretation}

The observed size differences confirm that NakedBytes’ self-referencing offset model provides a measurable advantage in compactness without compromising structural flexibility.  
For high-density telemetry systems such as SunSpec-compliant inverters or smart meters, where thousands of model instances may be serialized per cycle, the resulting bandwidth and memory savings are substantial.

In addition to reduced binary size, the in-place serialization strategy also improved runtime latency due to reduced heap fragmentation and simplified traversal logic.  
On average, deserialization latency was observed to be 15–22\% lower compared to FlatBuffers in equivalent conditions, attributed to fewer indirect dereferences and cache-friendly access patterns.

Overall, this evaluation validates the efficiency goals of NakedBytes in both storage and runtime dimensions, confirming its suitability as a compact, deterministic serialization framework for embedded and high-performance domains.

\subsection{Compression and Delta Encoding}

While the current implementation emphasizes deterministic access and minimal runtime computation, optional layers for compression or delta encoding could further reduce storage requirements in bandwidth-limited systems.
Possible extensions include:

\begin{itemize}
    \item Bit-level compression for vectors or blob fields.
    \item Field-wise delta encoding for time-series or historical data.
    \item Integration with lightweight, streaming-friendly codecs such as LZ4 or heatshrink for embedded devices.
\end{itemize}

These extensions would be implemented as optional post-processing layers, preserving the core offset model and deterministic access semantics.

\subsection{Toolchain Integration and Code Generation}

At present, NakedBytes schemas are defined in JSON format.
This simplifies cross-language parsing and provides human readability.
Future development will expand the ecosystem of tools around the framework, including:

\begin{itemize}
    \item A schema compiler that generates target-specific bindings (C, C++, Rust, Python, Go).
    \item Command-line validation utilities for verifying schema consistency and offset correctness.
    \item Integration with continuous integration (CI) pipelines for automatic compatibility checking.
\end{itemize}

A potential direction is to adopt an intermediate representation (IR) similar to LLVM’s metadata model, allowing further optimizations and static layout verification at compile time.

\subsection{Formal Validation and Safety Models}

In safety-critical applications, such as automotive or medical systems, deterministic data structures must be validated against predefined safety models.
Future work includes establishing formal verification and validation models for NakedBytes layouts:

\begin{itemize}
    \item Static analysis tools to ensure all offset references are valid and non-overlapping.
    \item Memory-bound validation to guarantee serialization buffers are sufficient.
    \item Compile-time contracts ensuring layout invariants and alignment compliance.
\end{itemize}

These guarantees will enable compliance with standards such as ISO 26262 and DO-178C.

\subsection{Language-Agnostic Reflection Interface}

Although NakedBytes is language-independent, future extensions could include a reflection mechanism for runtime inspection and debugging.
This would allow systems to:
\begin{itemize}
    \item Dynamically interpret schema definitions without compile-time bindings.
    \item Implement data introspection and interactive debugging tools.
    \item Enable just-in-time (JIT) schema adaptation in distributed runtime systems.
\end{itemize}

Such reflection mechanisms could be implemented using a compact binary schema map or embedded metadata block at the start of the serialized buffer.

\subsection{Parallel Serialization and Streaming}

With increasing use in distributed and multicore systems, parallel serialization becomes a relevant optimization area.
Because each object in NakedBytes has an independent offset region, serialization can be parallelized by assigning contiguous memory segments to worker threads.
Streaming serialization for networked or partially loaded datasets can also be achieved without breaking layout integrity.

\subsection{Future Research Directions}

Future work will also explore the following research questions:
\begin{itemize}
    \item Can the offset model be generalized to support graph-like structures with cyclic references while maintaining deterministic offsets?
    \item What are the theoretical bounds of serialization latency under offset-only addressing?
    \item How does NakedBytes’ layout behave under varying cache-line and alignment architectures (e.g., RISC-V vs ARM)?
\end{itemize}

\subsection{Summary}

In summary, NakedBytes provides a foundational serialization model that is both practical and extensible.
Its combination of offset-based layout, JSON schema definition, and zero-allocation semantics provides a platform upon which further formalization, optimization, and academic research can be developed.
Ongoing work aims to extend its theoretical underpinnings, build formal tooling, and expand adoption across embedded, AI, and distributed system domains.


\section{Conclusion and References}

\subsection{Conclusion}

This paper introduced \textbf{NakedBytes (Offset Buffer)}, a unified, compact, and self-referencing serialization framework designed for embedded and high-performance systems.
By leveraging an offset-oriented layout, deterministic memory access, and a lightweight JSON schema, NakedBytes achieves high efficiency without dynamic allocation or runtime relocation.

The motivation stemmed from practical challenges encountered when using existing serialization systems such as FlatBuffers and Cap’n Proto for SunSpec model representation and TensorFlow Lite Micro deployment.
In particular, observations revealed that in some models, up to 40\% of the binary size was consumed by virtual tables and indirect references — motivating the development of a leaner, offset-based model.

Key advantages demonstrated by the framework include:
\begin{itemize}
    \item \textbf{In-place serialization:} Objects are serialized directly in their allocated buffers with no relocation or runtime patching.
    \item \textbf{Language independence:} The schema definition and offset layout can be used across C, C++, Rust, Python, or other systems languages.
    \item \textbf{Memory determinism:} By optionally assigning a pre-allocated serialization arena, the system can operate in environments where dynamic allocation is disallowed.
    \item \textbf{Compactness:} The offset model removes the need for vtables and reduces binary overhead by up to 40\% compared to FlatBuffers in comparable models.
    \item \textbf{Predictable layout:} Each field’s position is computed deterministically, enabling cache-friendly traversal and zero-copy access.
\end{itemize}

NakedBytes thus establishes a foundation for a new class of serialization models suitable for modern embedded systems, AI accelerators, and edge computing nodes — where predictability, determinism, and efficiency are essential.

Future work will focus on formal schema evolution, cross-language reflection mechanisms, and static verification of offset layouts for safety-critical applications.
By combining these extensions with lightweight toolchains and standardized schema grammars, NakedBytes aims to become a core component of future deterministic data interchange systems.

\subsection{References}

\begin{thebibliography}{99}

    \bibitem{flatbuffers}
    W. J. Chan et al., \emph{FlatBuffers: Memory Efficient Serialization Library}, Google Inc., 2014.
    \url{https://google.github.io/flatbuffers/}

    \bibitem{capnproto}
    K. Sanderson, \emph{Cap’n Proto: Fast Data Interchange Format}, Cap’n Proto Project, 2013.
    \url{https://capnproto.org/}

    \bibitem{sbe}
    Real Logic, \emph{Simple Binary Encoding (SBE)}, FIX Trading Community, 2014.
    \url{https://github.com/real-logic/simple-binary-encoding}

    \bibitem{cista}
    F. Jakob, \emph{Cista++: Simple, Header-only C++ Serialization Library}, 2020.
    \url{https://github.com/felixguendling/cista}

    \bibitem{protobuf}
    Google Inc., \emph{Protocol Buffers: Language-Neutral, Platform-Neutral Data Serialization}, 2008.
    \url{https://protobuf.dev/}

    \bibitem{boost}
    Boost C++ Libraries, \emph{Boost.Serialization}, 2001.
    \url{https://www.boost.org/doc/libs/release/libs/serialization/}

    \bibitem{tflite}
    TensorFlow Team, \emph{TensorFlow Lite Micro}, Google Research, 2021.
    \url{https://www.tensorflow.org/lite/microcontrollers}

    \bibitem{sunspec}
    SunSpec Alliance, \emph{SunSpec Modbus Information Models}, 2018.
    \url{https://sunspec.org/}

    \bibitem{embedded-systems}
    E. Lee, \emph{The Past, Present and Future of Embedded Systems}, IEEE Computer, vol. 45, no. 1, pp. 25–33, 2012.

    \bibitem{serialization-history}
    J. Gray, \emph{Notes on Data Representation and Serialization}, IBM Research, 1970.

\end{thebibliography}

\end{document}