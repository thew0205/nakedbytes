g++ -g ./power_meter_protobuf_serialization_without_access.cpp  power_meter.pb.cc -lprotobuf -o ./power_meter_protobuf_test  $(pkg-config --cflags protobuf) $(pkg-config --libs protobuf) && ./power_meter_protobuf_test

protoc --cpp_out=. -I=. ./power_meter.proto
protoc --encode PowerMeter.MeterData ./power_meter_protobuf.proto < ./power_meter_protobuf_data.txt > ./power_meter_protobuf_data.bin



flatc -o ./ --cpp power_meter.fbs  
flatc --binary -o ./ power_meter.fbs ./power_meter_data_flatbuffers.json


nm --size-sort -r --print-size ./power_meter_nakedbytes_test | c++filt > temp

/usr/bin/time -v ./power_meter_nakedbytes_test


objdump  ./power_meter_nakedbytes_test > temp

size ./power_meter_nakedbytes_test

python3 /home/busoye_tm/Documents/matthew/projects/nakedbytes/code_implementation/nakedbytes.py --cpp . -b ./power_meter_nakedbytes_data.json power_meter_nakedbytes.json 



valgrind --tool=massif ./power_meter_nakedbytes_test
valgrind --tool=massif --stacks=yes ./power_meter_nakedbytes_test
ms_print massif.out.*


top
htop
pmap <pid>




To get the memory size breakdown of a C++ program, there are several levels depending on what you want: binary size, runtime memory, heap/stack usage, or per-object memory.

Below is a clear, practical map, starting from static size ‚Üí runtime memory ‚Üí per-object memory.

1Ô∏è‚É£ Binary size breakdown (compile-time / static)
‚úÖ Total binary size
ls -lh your_program
size your_program


Example output:

text    data     bss     dec     hex
123456  2345     6789    132590  205ce

Meaning
Section	Meaning
text	Code + read-only data
data	Initialized globals
bss	Zero-initialized globals
dec	Total
hex	Same in hex
üîç Detailed section breakdown
objdump -h your_program


or:

readelf -S your_program


Shows:

.text

.rodata

.data

.bss

.heap (if present)

.stack (platform dependent)

2Ô∏è‚É£ Function-level size (code bloat analysis)
nm --size-sort --print-size your_program | c++filt


Sort largest first:

nm --size-sort -r --print-size your_program | c++filt


Useful for:

template bloat

protobuf / flatbuffers size impact

unused functions

3Ô∏è‚É£ Runtime memory usage (Linux)
‚úÖ Total memory (RSS, heap, stack)
/usr/bin/time -v ./your_program


Output:

Maximum resident set size (kbytes): 15432

üîç Track heap usage (malloc/free)
Valgrind
valgrind --tool=massif ./your_program
ms_print massif.out.*


Shows:

heap usage over time

peak allocations

üî• Live tracking
top
htop
pmap <pid>

4Ô∏è‚É£ Per-object memory size (C++ level)
‚úÖ sizeof
std::cout << sizeof(MyStruct) << std::endl;


Includes:

padding

alignment

üîç Layout inspection (VERY useful)
#include <iostream>

struct Example {
    char a;
    int b;
    double c;
};

int main() {
    std::cout << sizeof(Example) << "\n";
    std::cout << offsetof(Example, a) << "\n";
    std::cout << offsetof(Example, b) << "\n";
    std::cout << offsetof(Example, c) << "\n";
}

üß† STL containers (important!)
std::vector<int> v(100);

sizeof(v);          // usually 24 bytes
v.capacity() * sizeof(int); // heap usage


Total memory ‚âà control block + heap buffer

5Ô∏è‚É£ Stack usage (embedded-critical)
GCC stack usage file
-fstack-usage


Generates:

file.su


Example:

main 64 static

6Ô∏è‚É£ Embedded / bare-metal memory
Map file (MOST IMPORTANT)
-Wl,-Map=output.map


Shows:

exact RAM usage

exact FLASH usage

7Ô∏è‚É£ Protobuf / FlatBuffers specific
Compare code size impact
size flatbuffers_app
size protobuf_app
size nanopb_app


You‚Äôll typically see:

nanopb   << protobuf << flatbuffers

üß† Summary table
Goal	Tool
Binary size	size, readelf
Function size	nm --size-sort
Runtime memory	/usr/bin/time, top
Heap tracking	valgrind massif
Stack usage	-fstack-usage
Object layout	sizeof, offsetof
Embedded memory	linker map